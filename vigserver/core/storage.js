/*　China Fujian Huanyutong Technology Co., Ltd. */
const path=require("path"),fs=require("fs"),assert=require("assert"),Datastore=require("nedb"),{readYamlFile:readYamlFile}=require("../utils/yaml"),async=require("async"),Documents=[{name:"devices",indexs:[{name:"sn",unique:!0}]},{name:"users",indexs:[{name:"name",unique:!0}]},{name:"devicetypes",indexs:[{name:"name",unique:!0}]},{name:"rules",indexs:[{name:"name",unique:!0}]},{name:"services",indexs:[{name:"name",unique:!0}]},{name:"apps",indexs:[{name:"name",unique:!0}]}],StorageLocation=path.join(VIGConsts.DataRootFolder,"storage"),{diffJsonItems:diffJsonItems}=require("../utils/jsonfuncs");class DocumentRecord{constructor(e,t="_id"){this.storageName=e,this.storagePrimaryKey=t,this.attrs={},this.pk=null}setAttrs(e){Object.assign(this.attrs,e),this.pk=this.attrs[this.storagePrimaryKey]}async update(e,t=!1){let s=e,r=0;if(t||(s=diffJsonItems(this.attrs,e)),R.isEmpty(s))logger.warn(_("{storage} record are not updated:{attrs}").params(this.storageName.firstUpper(),JSON.stringify(e)));else if((r=await this.save(s))>0)return this.setAttrs(s),s}async load(e){e||(e=this.pk);let t=await VIGStorage.getDocument(this.storageName),s=await t.findOne({[this.storagePrimaryKey]:void 0===e?this[this.storagePrimaryKey]:e});if(!s)throw new Error("{storage} record <{pk}> is not exists".params(this.storageName.firstUpper(),e));return this.setAttrs(s),this.pk=e,s}async loadByQuery(e){let t=await VIGStorage.getDocument(this.storageName),s=await t.findOne(e);if(!s)throw new Error(`${this.storageName.firstUpper()} record is not exists:${String(e)}`);return this.setAttrs(s),s}async save(e,t={}){e||(e=this.attrs);let s=await VIGStorage.getDocument(this.storageName);if(this.attrs[this.storagePrimaryKey]!==this.pk)throw logger.warn(_("Cannot save record[{doc}.{sn}={pk}]").params(this.storageName,this.storagePrimaryKey,this.storagePrimaryKey)),new Error("The record update error");try{return await s.update({[this.storagePrimaryKey]:this[this.storagePrimaryKey]},{$set:e},t)}catch(e){throw logger.error(_("Error while save record[{doc}.{sn}={pk}] : {err}").params(this.storageName,this.storagePrimaryKey,this.storagePrimaryKey,e.message)),new Error("The record update error")}}}class StorageDocument{constructor(e,t=[]){this.document=null,this.name=e,this.indexs=t,this.filename=path.join(StorageLocation,this.name+".dat"),this.ready=!1}assertReady(){assert.equal(this.ready,!0,"The document is not opened.")}async open(){await new Promise((e,t)=>{this.document=new Datastore({filename:this.filename}),this.document.loadDatabase(async s=>{if(s)logger.error(_("Error while open document <{name}>:{message}").params(this.name,s.stack)),this.ready=!1,t(s);else{for(let e of this.indexs){let t="string"==typeof e?e:e.name;if(!(t in this.document.indexes))try{await new Promise((s,r)=>{this.document.ensureIndex({fieldName:t,unique:"string"!=typeof e&&(void 0!==e.unique&&e.unique),sparse:"string"!=typeof e&&(void 0!==e.sparse&&e.sparse)},e=>{e?r(e):s()})})}catch(t){logger.warn(_("Cannot create index ：{name}").params(e.name))}}this.ready=!0,e()}})}),await this.importInitData(),await this.compact()}async close(){return this.assertReady(),new Promise((e,t)=>{this.document.persistence.compactDatafile(),setTimeout(()=>{this.document=null,e()},2e3)})}async update(e,t,s={}){return this.assertReady(),s=Object.assign({multi:!0},s),new Promise((r,a)=>{this.document.update(e,t,s,(e,t,n,i)=>{e?a(e):s.returnUpdatedDocs?r(n):r(t)})})}async find(e){return this.assertReady(),new Promise((t,s)=>{this.document.find(e,(e,r)=>{e?s(e):t(r)})})}async findOne(e){return this.assertReady(),new Promise((t,s)=>{this.document.findOne(e,(e,r)=>{e?s(e):t(r)})})}async getAll(){return this.assertReady(),new Promise((e,t)=>{this.document.find({},(s,r)=>{s?t(s):e(r)})})}async remove(e,t){return this.assertReady(),new Promise((s,r)=>{this.document.remove(e,t,(e,t)=>{e?r(e):s(t)})})}async ensureIndex(e,t,s){return this.assertReady(),new Promise((r,a)=>{let n={fieldName:e};t&&(n[t]=t),s&&(n[s]=s),this.document.ensureIndex(n,function(e){e?a(e):r()})})}async removeIndex(e){return this.assertReady(),new Promise((t,s)=>{this.document.removeIndex(e,function(e){e?s(e):t()})})}async insert(e){return this.assertReady(),new Promise((t,s)=>{this.document.insert(e,(e,r)=>{e?s(e):t(r)})})}async empty(){return this.assertReady(),new Promise((e,t)=>{this.document.remove({},{multi:!0},(s,r)=>{s?t(s):e(r)})})}async count(){return this.assertReady(),new Promise((e,t)=>{this.document.count({},(s,r)=>{s?t(s):e(r)})})}async compact(){this.assertReady(),this.document.persistence.compactDatafile()}__setHostSerialNo(e){for(let t of e)if("__host__"===t.sn)return t.sn=VIGPlatform.sn,void(t.__host__=!0)}async importInitData(){return new Promise((e,t)=>{async.waterfall([e=>{this.document.count({},(t,s)=>{e(null,s)})},(e,t)=>{if(0===e){let e=path.join(VIGConsts.DataRootFolder,"initdata",this.name+".yaml");if(fs.existsSync(e))try{logger.info(_("Importing initdata from <{file}>.").params(e));let s=readYamlFile(e).records;this.__setHostSerialNo(s),this.document.insert(s,(e,s)=>{t(e,s)})}catch(s){logger.warn(_("Error while importing initdata from <{file}> : {err}").params(e,s.stack)),t(s,[])}else t(null,[])}else t(null,[])},(e,t)=>{e.length>0&&logger.debug(_("Importing {num} lines of data to the table[{docname}]").params(e.length,this.name)),t(null)}],(s,r)=>{s?t(s):e()})})}}class StorageManager{constructor(){this.documents={}}async init(){for(let e of Documents){let t="string"==typeof e?e:e.name,s="string"==typeof e?[]:e.indexs||[];try{let e=new StorageDocument(t,s);await e.open(),this.documents[t]=e}catch(e){logger.warn(_("Error while open storage document <{doc}> : {err}").params(t,e.stack))}}}async getDocument(e){return e in this.documents?this.documents[e]:await this.openDocument(e)}async openDocument(e,t=[],s=!1){if(e in this.documents&&!1===s)return this.documents[e];{delete this.documents[e];let s=new StorageDocument(e,t);return await s.open(),this.documents[e]=s,s}}deleteDocument(e){let t=path.join(this.location,e+".dat");try{e in this.documents&&(this.documents[e].close(),delete this.documents[e]),fs.unlinkSync(t),resolve()}catch(e){reject(e.stack)}}clear(){let e=require("fs-extra");logger.debug(_("Ready to clear storages")),e.emptySync(this.location)}async reset(){try{for(let e in this.documents)await this.documents[e].close();this.documents={}}catch(e){logger.debug(_("Error while close storages:{error}").params(getError(e)))}await this.init()}}module.exports={StorageManager:StorageManager,DocumentRecord:DocumentRecord,StorageDocument:StorageDocument};