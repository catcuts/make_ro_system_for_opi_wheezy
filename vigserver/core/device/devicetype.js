/*ã€€China Fujian Huanyutong Technology Co., Ltd. */
const DeviceProxyBase=require("./deviceproxy").DeviceProxyBase,{VIGModule:VIGModule}=require("core/vigmodule"),Notifys=require("core/eventbus/notifys"),{MessageTypes:MessageTypes,DeviceEventCodes:DeviceEventCodes,MessageAnswer:MessageAnswer}=require("core/protocols/vimp/constants"),{extractJsonItems:extractJsonItems,filterJsonByKeys:filterJsonByKeys,cloneJson:cloneJson,diffJsonItems:diffJsonItems}=require("utils/jsonfuncs"),VIMPAlarms=require("core/protocols/vimp/alarmdef"),{setMessageFlags:setMessageFlags}=require("services/vmc/utils"),SessionTimeOutError=require("utils/session").SessionTimeoutError,VIMPMessages=require("core/protocols/vimp/message"),VIMPErrors=require("core/protocols/vimp/errors"),{triggerEventTransaction:triggerEventTransaction}=require("core/transactions"),{EventThrottler:EventThrottler}=require("core/device/throttler"),{getDeviceAttrClass:getDeviceAttrClass}=require("./deviceattr"),{isJson:isJson}=require("utils/typecheck"),deepMerge=require("deep-extend"),dayjs=require("dayjs"),util=require("util"),defaultReservedAttrs=["_id","meta","advanced","entry","behavior","services"],defaultQueryAttrs=["sn","name","type","model","datetime","debug","language","domain","timeZone","charset","group","authorized","enabled"];class DeviceTypeBase extends VIGModule{constructor(e,t){super(t,{storageName:"devicetypes",storagePrimaryKey:"name",moduleType:"devicetype"}),this.server=e,this.__VIG_DEVICETYPE__=!0,this.devices={}}get inPort(){}get outPort(){return this.vmc}get advancedSettings(){return this.attrs.advanced||{}}get ruleEngine(){return this._ruleEngine||(this._ruleEngine=VIGServices.getServices("ruleengine")),this._ruleEngine}updateStatus(e,t,s){VIGDevices.updateDeviceStatus(e,t,s)}appendToDevices(e){e.sn in this.devices||(this.devices[e.sn]=e)}setAttrs(e){super.setAttrs(e),this.attrs.advanced=deepMerge({connectBehavior:2,msgHandleBehavior:0,readOnlyAttrs:["sn","version","authorized"],syncAttrs:[],softSyncAttrs:[],allowAddAttrs:[],allowDeleteAttrs:[],eventThrottle:{enabled:!0,excludes:[],interval:0},transaction:{events:[],alarms:[]},reservedAttrs:[],dateTimeFormat:"YYYYMMDDHHmmss"},e.advanced||{}),this.attrs.meta=deepMerge({attrs:{sn:{title:_("SerialNo"),valuetype:"string",readOnly:!0},name:{title:_("Name"),valuetype:"string"},model:{title:_("Model"),valuetype:"string"},enabled:{valuetype:"boolean",default:!0},authorized:{valuetype:"boolean"},version:{valuetype:"string"}}},e.meta||{}),this.attrs.advanced.readOnlyAttrs=R.keys(R.pickBy(e=>!!e&&e.readOnly,this.attrs.meta.attrs)),this.attrs.advanced.syncAttrs=R.keys(R.pickBy(e=>!!e&&2===e.sync,this.attrs.meta.attrs)),this.attrs.advanced.softSyncAttrs=R.keys(R.pickBy(e=>!!e&&1===e.sync,this.attrs.meta.attrs)),this.attrs.advanced.allowDeleteAttrs=R.keys(R.pickBy(e=>!!e&&e.allowDelete,this.attrs.meta.attrs)),this.attrs.advanced.reservedAttrs=R.concat(R.keys(R.pickBy(e=>!!e&&e.reserved,this.attrs.meta.attrs)),defaultReservedAttrs),this.attrs.advanced.reservedAttrs=R.uniq(this.attrs.advanced.reservedAttrs)}async loadRemainDevices(){try{let e=await this.devicesStorage.find({type:this.name,enabled:!0,remain:!0});for(let t of e){let e=await this.getDeviceProxy(t,!0,this);this.appendToDevices(e)}}catch(e){logger.error(_("Error while load remain devices:{error}").params(e.stack))}}async init(){this.devicesStorage=await VIGStorage.getDocument("devices"),await this.loadRemainDevices()}filterSyncAttrs(e={}){let t=this.advancedSettings.syncAttrs,s=this.advancedSettings.softSyncAttrs;if(Array.isArray(t)||(t=[t]),Array.isArray(s)||(s=[s]),Array.isArray(e)){let r=[[],[],[]];for(let s of t)e.includes(s)&&r[0].push(s);for(let t of s)e.includes(t)&&r[1].push(t);for(let t of e)r[0].includes(t)&&r[1].includes(t)&&r[2].push(t);return r}if("object"==typeof e){let r=[{},{},{}];for(let s of t)s in e&&(r[0][s]=e[s]);for(let t of s)t in e&&(r[1][t]=e[t]);return r[2]=filterJsonByKeys(e,[...R.keys(r[0]),...R.keys(r[1])],!0),r}}async syncAttrsToDevice(e,t={}){let s={},r={},[a,i]=this.verifyAttrValue(t),o={},[n,l,c]=this.filterSyncAttrs(a);if(!R.isEmpty(n))try{let t=await this.sendMessageToDevice(VIMPMessages.Attrs({to:e,flags:{receipt:!0},attrs:{_batch_:!0,...n}}),!0);t.payload.code===MessageAnswer.OK?(logger.info(_("Sync attrs <{attrs}> to device <{sn}> is success").params(R.keys(n).join(","),e)),o=await this.saveAttrsToStorage(e,n),Object.assign(s,o),o={}):logger.info(_("Sync attrs <{attrs}> to device <{sn}> is fail:{code}").params(R.keys(n).join(","),e,t.payload.code))}catch(t){logger.error(_("Error while sync attrs <{attrs}> to device <{sn}> :{err}").params(JSON.stringify(n),e,t.message)),Object.assign(r,n),r._error=t.message}if(!R.isEmpty(l))try{o=await this.saveAttrsToStorage(e,l),(await this.sendMessageToDevice(VIMPMessages.Attrs({to:e,flags:{receipt:!0},attrs:{_batch_:!0,...l}}),!0)).payload.code===MessageAnswer.OK?Object.assign(s,o):Object.assign(r,l),o={}}catch(e){logger.error(_("Error while sync attrs({attrs}) to device:{err}").params(JSON.stringify(l),e.message)),Object.assign(r,l),r._error=e.message}if(!R.isEmpty(c))try{o=await this.saveAttrsToStorage(e,c),Object.assign(s,o)}catch(e){logger.error(_("Error while save attrs to storage:{err}").params(e.message)),Object.assign(r,c),r._error=e.message}return[s,r,i]}get meta(){return this.attrs.meta||{}}isValidAttr(e){return e in this.meta.attrs}getAttrMeta(e){let t=Object.assign({title:"",valuetype:"string",choices:[],readOnly:!1,default:null,help:"",validator:null},this.meta.attrs[e]||{});return t.name=e,this.isValidAttr(e)?t:null}filterAttrs(e){let t={},s={},r={};for(let a in e)if(a in this.meta.attrs){let r=this.getAttrMeta(a);r&&("devices"===r.storage||void 0===r.storage?t[a]=e[a]:(e[a].meta=r,s[r.storage]={[a]:e[a]}))}else r[a]=e[a];return[t,s,r]}async saveAttrsToExternalStorage(e){let t={};for(let s in e)try{let r=e[s],a=new(getDeviceAttrClass(r.meta.storage))(r.meta),i=await a.update(r.query,r.value);t[s]=i}catch(e){let t=_("Error while updateing device attr <{name}>:{error}").params(s,e.message);throw logger.debug(t),new VIMPErrors.FailError(e.message)}return t}async saveAttrsToStorage(e,t){if(R.isEmpty(t))return{};let s={},[r,a]=this.filterAttrs(t);if(!R.isEmpty(r)||!R.isEmpty(a)){if(R.isEmpty(r)||(await VIGDevices.saveDeviceToStorage({sn:e,...r}),Object.assign(s,r),await this.renewRemainDeviceProxy(e)),!R.isEmpty(a)){let e=[];for(let t in a)try{e=await this.saveAttrsToExternalStorage(a[t]),Object.assign(s,e)}catch(e){throw new VIMPErrors.FailError(e.message)}}return s}logger.warn(_("Unable save attrs to storage:{attrs}").params(JSON.stringify(t)))}async deleteDeviceAttrs(e,t){"string"==typeof t?t=t.split(","):Array.isArray(t)||(t=[t]);let s={};for(let e of t)s[e]=!0;let r=await this.devicesStorage.update({sn:e},{$unset:{...s}});return await this.renewRemainDeviceProxy(e),r}async getDeviceAttrsFromStorage(e){return await this.devicesStorage.findOne({sn:e})}async renewRemainDeviceProxy(e){try{let t=await this.getDeviceProxy(e);t&&await t.reload()}catch(t){logger.warn(_("Error while renew remain deviceproxy <{sn}>:{error}").params(e,t.stack))}}publishNotify(e,t={}){let s="devicetype."+this.name.toLowerCase();e===Notifys.DeviceAttrsChange?s+=".attrs":e===Notifys.DeviceStatusChange?s+=".status":e===Notifys.DeviceChildrenAuthorize&&(s+=".children"),this.node.publish(s,t)}publishEvent(e={}){this.node.publish("devicetype."+this.name.toLowerCase()+".events",e)}publishAlarm(e={}){this.node.publish("devicetype."+this.name.toLowerCase()+".alarms",e)}async addDeviceAttr(e,t){if(t.operate=this.advancedSettings.allowAddAttrs.includes(t.name))return await this.saveAttrsToStorage(e,{[t.name]:t.value});throw new VIMPErrors.DeniedError}isEnableRuleEngine(e){return!0}getArrayAttrMaxLength(e){return 100}onAfterAttrsUpdate(e,t){logger.debug(_("Attrs <{attrs}> is updated.").params(R.keys(t).join(",")))}verifyAttrValue(e){return[cloneJson(e),{}]}async getAttrValue(e,t=""){return(await this.devicesStorage.findOne({sn:e}))[t]}async updateBatchAttrs(e,t){if(R.isEmpty(t))throw new VIMPErrors.ParamError(_("No parameters"));let[s,r,a]=this.filterAttrs(t),i=R.keys(s).length;if(!R.isEmpty(r))throw new VIMPErrors.UnsupportedError(_("Attributes <{attrs}> does not support batch updates.").params(R.keys(r).join(",")));let o={};if(0===i)throw new VIMPErrors.FailError(_("Invalid attributes:{error}").params(R.keys(t).join(",")));{let t=await this.getDeviceAttrsFromStorage(e),i=diffJsonItems(t,s,!1);if(R.isEmpty(i)){if(logger.warn(_("Attributes has no change, no updated.")),!R.isEmpty(r))throw new VIMPErrors.ParamError(_("Cannot be updating attrs <{attrs}> in a batch way").params(R.keys(r).join(",")));if(!R.isEmpty(a))throw new VIMPErrors.ParamError(_("Invalid attrs:{attrs}").params(R.keys(a).join(",")))}else{let[t,s]=await this.syncAttrsToDevice(e,i);if(Object.assign(o,t),R.isEmpty(t))throw new VIMPErrors.FailError("Update fail:",Object.assign(s,a))}return o}}async updateSingleAttr(e,t){let s=t.name,r={},a={},i=this.getAttrMeta(s);if(null===i)throw new VIMPErrors.ParamError(_("Invalid device attr <{attr}>").params(s));if(void 0===s||void 0===t.value)throw new VIMPErrors.ParamError(_("Lost name parameter"));if(this.advancedSettings.readOnlyAttrs.includes(s))throw new VIMPErrors.DeniedError(_("Read-only attribute"));if(i.storage&&"devices"!==i.storage)r={[s]:{name:s,value:t.value,query:t.for}};else if(a=await this.getAttrValue(e,s,i.storage),Array.isArray(a)){let e=parseInt(t.for);if(e)if(e<a.length)a[e]=t.value,r={[s]:a};else{if(!(e<this.getArrayAttrMaxLength(s)))throw new VIMPErrors.FailError(_("Invalid array index"));a.push(t.value),r={[s]:a}}else{if(!Array.isArray(t.value))throw new VIMPErrors.ParamError(_("Invalid <for> parameter"));r={[s]:t.value}}}else if(util.isObject(a)){let e=String(t.for);if(e&&"string"==typeof e&&e in a)r={[s]:Object.assign(a,{[e]:t.value})};else{if("object"!=typeof t.value)throw new VIMPErrors.ParamError(_("Invalid <for> parameter"));r={[s]:t.value}}}else a===t.value||void 0!==a&&typeof a!=typeof t.value||(r={[s]:t.value});if(R.isEmpty(r))throw new VIMPErrors.FailError(_("Attribute {name} is not updated").params(s));{let[t,s,a]=await this.syncAttrsToDevice(e,r);if(!R.isEmpty(a))throw new VIMPErrors.FailError(a._error||_("Invalid attr value:{attrs}").params(R.keys(a).join(",")));if(!R.isEmpty(s))throw new VIMPErrors.FailError(s._error||_("Update fail:{attrs}").params(R.keys(s).join(",")));return t}}onUnload(){}getProxyClass(){return DeviceProxyBase}async getDeviceProxy(e,t=!1){if(e in this.devices)return this.devices[e];if(t){let t=new(this.getProxyClass())("string"==typeof e?e:e.sn,this);return"string"==typeof attrsOrSn?await t.load():t.from(e),t}}noticeUpdateDeviceAttrs(e="",t={}){this.onMessage(VIMPMessages.Attrs({to:e,flags:{receipt:!1},type:MessageTypes.Attrs,payload:{_batch_:!0,...t}}))}async _UpdateAttrsOperate(e){let t=e.to,s={};return"_batch_"in e.payload?(delete e.payload._batch_,s=await this.updateBatchAttrs(t,e.payload)):s=await this.updateSingleAttr(t,e.payload),this.publishNotify(Notifys.DeviceAttrsChange,{sn:t,attrs:s}),R.isEmpty(s)||await this.onAfterAttrsUpdate(t,s),s}async _AddAttrsOperate(e){return await this.addDeviceAttr(e.to,e.payload)}async _DeleteAttrsOperate(e){}async onAttrsMessage(e){let t="",s={};if("number"==typeof e.payload.operate){let s=parseInt(e.payload.operate);t=["update","delete","add"][s>2||s<0?e.payload.operate:0]}else t=e.payload.operate||"update";return"update"===t?s=await this._UpdateAttrsOperate(e):"add"===t?s=await this._AddAttrsOperate(e):"delete"===t&&(s=await this._DeleteAttrsOperate(e)),R.isEmpty(s)?VIMPMessages.Answer({message:_("Attrs has no updated")}):[VIMPMessages.AttrsChangeEvent({attrs:s}),VIMPMessages.Answer({payload:{updated:R.keys(s)}})]}async onEventMessage(e){let t=EventThrottler(e,this.advancedSettings.eventThrottle||{});if(null!==t){if(triggerEventTransaction(t,this.advancedSettings.transaction||{}),this.isEnableRuleEngine())try{this.ruleEngine.execute(t,{Event:t.payload}),setMessageFlags(t,{reply:!0})}catch(e){logger.warn(_("Error while execute rule for message of event :{error}").params(e.message))}return this.publishEvent(t),VIMPMessages.Event(t)}}async onAnswerMessage(e){}async onAlarmMessage(e){return this.publishAlarm(e.payload),VIMPMessages.Alarm(e)}async queryExtDeviceAttrs(e){let t,s={};for(let r of e){if("string"==typeof r?(t=this.getAttrMeta(r),r={name:r,query:{where:""},falgs:{}}):("string"==typeof r.query&&(r.query={where:r.query}),t=this.getAttrMeta(r.name)),!t)throw new VIMPErrors.UnsupportedError(_("Unsupported attributes."));{let e=new(getDeviceAttrClass(t.storage))(t);try{s[r.name]=await e.find(r.query,r.flags)}catch(e){s[r.name]="ERROR({})".params(e.message)}}}return s}isExtDeviceAttr(e){let t=this.getAttrMeta(e);return!!t&&(void 0!==t.storage&&"devices"!==t.storage)}filterExtAttrs(e=[]){let t=[];for(let s of e)"string"==typeof s?this.isExtDeviceAttr(s)&&t.push(s):isJson(s)&&this.isExtDeviceAttr(s.name)&&t.push(s);return t}async queryDeviceAttrs(e){let t={},s=e.payload.fields,r=e.to,a=await VIGDevices.findOne({sn:r});if(1===s.length&&"*"!==s[0]){let r=this.getAttrMeta(s[0]);t=this.isExtDeviceAttr(s[0])?await this.queryExtDeviceAttrs([{name:s[0],query:e.payload.query,flags:e.payload.flags}]):{[s[0]]:a[s[0]]||r.default}}else t=s.length>1?extractJsonItems(a,s):extractJsonItems(a,defaultQueryAttrs),Object.assign(t,await this.queryExtDeviceAttrs(this.filterExtAttrs(s)));let[i,o,n]=this.filterSyncAttrs(s);return R.isEmpty(i)||Object.assign(t,await this.querySyncDeviceAttrs(r,i)),!R.isEmpty(o)&&forceSync&&Object.assign(t,await this.querySyncDeviceAttrs(r,o)),t=filterJsonByKeys(t,this.advancedSettings.reservedAttrs,!0)}async querySyncDeviceAttrs(e,t){let s={},r=await this.sendMessageToDevice(VIMPMessages.Query({to:e,fields:t}),!0);if(200!==r.payload.code)throw new(VIMPErrors.getError(r.payload.code))(r.payload.message);return s=filterJsonByKeys(r.payload,["code","message"],!0),await this.saveAttrsToStorage(e,s),s}async queryDeviceStatus(e){if(e.to in this.devices){let t=this.devices[e.to].status,s={},r=e.payload.fields||[];return s=Array.isArray(r)&&r.length>0?extractJsonItems(t,r):t}throw new VIMPErrors.FailError(_("Invalid serialNo:{}").params(e.to))}async queryDeviceActions(e){}async queryDeviceChildren(e){if("vigateway"===this.name){let t={$and:[{type:{$ne:"vigateway"}},{$or:[{parent:this.host.sn},{parent:""},{parent:{$exists:!1}}]}]},s=await VIGDevices.find(t),r=[],a=e.payload.flags;return{children:r=0===a.format?s.map(e=>e.sn):1===a.format?s.map(e=>extractJsonItems(e,["name","sn","type","model","domain","enabled","authorized"])):s.map(e=>filterJsonByKeys(e,["_id"],!0))}}throw new VIMPErrors.ParamError(_("Unsupported operations"))}async onQueryMessage(e){let t=(e.payload.type||"").toLowerCase(),s=e.payload.fields||[];if("string"==typeof s)s=s.includes(",")?s.splice(","):[s];else if(!Array.isArray(s))throw VIMPErrors.ParamError(_("lose <fields> parameter"));e.payload.fields=s,e.payload.query=e.payload.query||{},e.payload.flags=Object.assign({format:1,support:!1,forceSync:!1},e.payload.flags||{});let r={};try{switch(t){case"attrs":r=await this.queryDeviceAttrs(e);break;case"status":r=await this.queryDeviceStatus(e);break;case"children":r=await this.queryDeviceChildren(e);break;case"meta":break;default:throw new VIMPErrors.FailError(_("Invalid query type:{type}").params(t))}return VIMPMessages.Answer({payload:{result:r}})}catch(e){throw new VIMPErrors.FailError(_("Failure to query:{error}").params(e.message))}}async onActionMessage(e){let t="";if(!("action"in e.payload))throw new VIMPErrors.ParamError("lost <action> parameters");try{let s="onAction"+(t=e.payload.action.toLowerCase()).firstUpper();if(""!==t&&s in this)return await this[s](e);{let e=_("Not supported action <{name}>.").params(t);throw new VIMPErrors.RejectError(e)}}catch(e){throw logger.error(_("Error while execute action {name}:{error}").params(t,e.stack)),new VIMPErrors.FailError(e.message)}}async onActionPing(e){return VIMPMessages.Answer({code:MessageAnswer.OK})}async onActionAuthorize(e){let t=e.to;if(VIGDevices.exists(t)){let s=Boolean(e.payload.authorized),r=void 0===e.payload.name?t:e.payload.name;return await this.authorize(t,r,s),this.publishNotify(Notifys.DeviceChildrenAuthorize,{sn:t,authorized:s}),VIMPMessages.Event({payload:{code:DeviceEventCodes.DeviceAuth,authorized:!0===s?1:2,source:t}})}throw new VIMPErrors.FailError(_("Device <{sn}> no exists.").params(t))}async authorize(e,t,s=!0){return(await this.sendMessageToDevice(VIMPMessages.Action({to:e,flags:{receipt:!0},payload:{action:"authorize",flags:{},authorized:s,name:t,datetime:dayjs().format(this.advancedSettings.dateTimeFormat)}}),!0)).payload.code===MessageAnswer.OK&&(await this.saveAttrsToStorage(e,{authorized:s,name:t,authTime:new Date}),s?logger.debug(_("Device <{sn}> authorize success").params(e)):logger.debug(_("Device <{sn}> cancel of authorize success").params(e)),!0)}async onNotifyMessage(e){}async onMessageMessage(e){}async onDataMessage(e){}isValidMessage(e){let t=[MessageTypes.Answer,MessageTypes.Register,MessageTypes.Event,MessageTypes.Alarm].includes(e.type)?e.from:e.to;return!!VIGDevices.exists(t)||(""===t||"FFFFFFFF"===t||"*"===t||e.type===MessageTypes.Register)}async sendMessageToDevice(e,t=!1){if(t){setMessageFlags(e,{receipt:!0});let t=null,s=e.to,r=this.inPort.createSession(s);try{if(t=await r.send(e),r.end(),null===t)throw new VIMPErrors.UnsupportedError(_("Get invalid answer while send message to device<{sn}>:{message}").params(s,JSON.stringify(e)));if(VIMPErrors.isError(t))throw new(VIMPErrors.getError(t.payload.code));return t}catch(e){throw r.end(),e instanceof SessionTimeOutError?(logger.debug(_("Timeout while send message to device:{err}").params(e.message)),new SessionTimeOutError(_("Timeout while send message to device"))):Error(_("Error while send message to device:{err}").params(e.message))}}else setMessageFlags(e,{receipt:!1}),this.inPort.sendToDevice(e)}async onRegisterMessage(e){logger.debug(_("Wireless device <{sn}> is being register.").params(e.from));let t=e.payload;t.sn=e.from,t.parent="";let s=await VIGDevices.findOne({sn:e.from,type:t.type});if(!s)return t.authorized=!1,t.registerDate=new Date,s=await VIGDevices.addDevice(t),VIMPMessages.Event({code:DeviceEventCodes.DeviceAuth,location:s.location||{},payload:{authorized:0,source:s.sn,model:s.model,name:s.name,type:s.type}});try{let e=void 0!==s.authorized&&s.authorized;return e&&(e=await this.authorize(s.sn,s.name,!0)),VIMPMessages.Event({code:DeviceEventCodes.DeviceAuth,payload:{authorized:!0===e?1:2,source:s.sn,model:s.model,name:s.name,type:s.type}})}catch(e){logger.warn(_("Error while authorize devie<{sn}>:{err}").params(t.sn,e.message))}}triggerEvent(e,t={}){this.outPort.triggerEvent(e,t)}triggerAlarm(e,t={}){this.outPort.triggerAlarm(e,t)}onMessage(e){if(!this.isValidMessage(e))return void logger.debug(_("The devicetype <{name}> receives an invalid message:{message}").params(this.name,JSON.stringify(e)));let t=null;try{t=[this.onRegisterMessage,this.onNotifyMessage,this.onAttrsMessage,"",this.onActionMessage,this.onAlarmMessage,this.onEventMessage,this.onMessageMessage,this.onDataMessage,this.onQueryMessage,"",this.onAnswerMessage][e.type].bind(this)}catch(t){logger.debug(_("Invalid vimp message type:{msg}").params(e))}t(e).then(t=>{let s=!1;if(t){Array.isArray(t)||(t=[t]);for(let r of t)"object"==typeof r?(r.sid=e.sid,r.to=r.type===MessageTypes.Answer?e.from:r.to,(r.type!==MessageTypes.Answer||r.type===MessageTypes.Answer&&e.flags.receipt)&&this.outPort.send(r,!1),!1===s&&r.type===MessageTypes.Answer&&(s=!0)):logger.warn("Invalid vimp message:{msg}".params(String(r)));s&&0!==t.length||!e.flags.receipt||this.outPort.send(VIMPMessages.Answer({}),!1)}}).catch(t=>{if(e.type===MessageTypes.Register)this.outPort.send(VIMPMessages.Alarm({code:VIMPAlarms.RegisterFail[0],source:e.from,message:t.message,level:VIMPAlarms.RegisterFail[1]}),!1);else{let s={sid:e.sid,to:e.from};t instanceof VIMPErrors.VIMPError?Object.assign(s,{code:t.code,message:t.message,payload:t.params||{}}):Object.assign(s,{code:MessageAnswer.Fail,message:t.message}),e.type!==MessageTypes.Answer&&e.flags.receipt&&this.outPort.send(VIMPMessages.Answer(s,!1))}})}async onNotify(e){}}module.exports={DeviceTypeBase:DeviceTypeBase};