/*　China Fujian Huanyutong Technology Co., Ltd. */
const ServiceBase=require("../../core/service/servicebase"),Notifys=require("core/eventbus/notifys"),{deserialize:deserialize,serialize:serialize,AnswerMessage:AnswerMessage,ErrorMessage:ErrorMessage,ReportMessage:ReportMessage,NoImplementErrorMessage:NoImplementErrorMessage,ParamErrorMessage:ParamErrorMessage}=require("./protocol"),MQTT=require("mqtt"),jsonpath=require("jsonpath"),fs=require("fs"),path=require("path"),assert=require("assert"),dayjs=require("dayjs"),{asyncSleep:asyncSleep,asyncWait:asyncWait}=require("utils/asyncutil");class DiscovererBase{constructor(e){this.discoverService=e,this.endpoint=null,this.isModifyNetwork=!1,this.isUpdateNetwork=!1,this.defaultNetworkInterface={},this.newNetworkInterface={}}async applyNetwork(e){try{let s="default"===e.interface||0===e.interface?VIGPlatform.network.defaultInterfaceName:e.interface;await this.disconnect(),await VIGPlatform.network.configure({[s]:e})}catch(e){throw await this.refreshNetwork(),new Error(_("Error while configutor network:{err}").params(e.message))}await this.refreshNetwork(),this.isUpdateNetwork=!0}async refreshNetwork(){this.defaultNetworkInterface=await VIGPlatform.network.default()}async verifyNetwork(e){return await this.refreshNetwork(),this.defaultNetworkInterface.dhcp?this.defaultNetworkInterface.dhcp===e.dhcp:this.defaultNetworkInterface.address===e.address&&(this.defaultNetworkInterface.netmask===e.netmask&&this.defaultNetworkInterface.gateway===e.gateway)}async backupNetwork(){this.currentNetworkConfig=VIGPlatform.network.backup()}clearBackupNetwork(){let e=path.join(VIGConsts.Folders.temp,"networks.json");if(fs.existsSync(e))try{fs.unlinkSync(e)}catch(e){}}async restoreNetwork(){!1!==this.currentNetworkConfig&&await VIGPlatform.network.restore()}disconnect(){}connect(){}reconnect(){}async start(){await this.backupNetwork(),await this.refreshNetwork()}async stop(){this.endTimingReport(),!this.isUpdateNetwork&&this.isModifyNetwork?await this.restoreNetwork():this.clearBackupNetwork()}startTimingReport(){this._intervalId>0&&clearInterval(this._intervalId),this._intervalId=setInterval(async()=>{await this.refreshNetwork(),this.report(await ReportMessage(this.defaultNetworkInterface))},this.settings.reportInterval)}endTimingReport(){this._intervalId>0&&(clearInterval(this._intervalId),this._intervalId=0)}async onBasicConfig(e){let s,t=e.payload;if(t.domain)try{await VIGateway.update({domain:t.domain||0})}catch(e){s=e.message}try{let e=await VIGServices.getServices("vmc"),r=e.attrs.transfers;jsonpath.apply(r,"$[?(@.name=='mqtt')]",e=>{let s={};return t.broker&&(s.broker=t.broker),t.username&&(s.username=t.username),t.password&&(s.password=t.password),e=Object.assign(e,s)}),await e.update({transfers:r},!0),logger.debug(_("Update gateway config success:{msg}").params(JSON.stringify(r)))}catch(e){s=e.message}s?this.answer(ErrorMessage({to:e.from,sid:e.sid,message:s})):this.answer(AnswerMessage({to:e.from,sid:e.sid,message:"success"}))}async onNetworkConfig(e){if(VIGPlatform.network.restarting)return void this.answer(ErrorMessage({sid:e.sid,to:e.from,message:"Is restarting"}));let s={};if(s.interface=void 0===e.payload.interface?"default":e.payload.interface,e.payload.dhcp&&(s.dhcp=e.payload.dhcp),e.payload.ip&&(s.address=e.payload.ip),e.payload.gateway&&(s.gateway=e.payload.gateway),e.payload.subnetmask&&(s.netmask=e.payload.subnetmask),e.payload.dns&&(s.dns=e.payload.dns),this.newNetworkInterface=s,this.answer(AnswerMessage({sid:e.sid,to:e.from,message:"The configuration has been accepted and restarted to take effect"})),!1!==e.payload.restart)try{this.answer(AnswerMessage({sid:e.sid,to:e.from,message:"The network is being configured"})),await asyncSleep(2e3),await this.applyNetwork(s),await asyncSleep(1e3),this.answer(AnswerMessage({sid:e.sid,to:e.from,message:"Network configutor success"})),this.report(await ReportMessage(this.defaultNetworkInterface)),this.endpoint.reconnect()}catch(s){this.answer(ErrorMessage({sid:e.sid,to:e.from,message:s.message}))}}async onWifiConfig(e){}async onLocationConfig(e){}async onReset(e){this.answer(AnswerMessage({sid:e.sid,to:e.from,message:"Is restarting"})),VIServer.end()}async onUpgrade(e){this.answer(NoImplementErrorMessage({sid:e.sid,to:e.from}))}async onSetAttrs(e){this.answer(NoImplementErrorMessage({sid:e.sid,to:e.from}))}async onGetAttrs(e){if("attrs"in e.payload){let s=Array.isArray(e.payload.attrs)?e.payload.attrs:e.payload.attrs.split(","),t=R.pick(s,VIGateway.attrs);if(s.includes("mqtt")){let e=R.pick(["broker","username"],this.getMqttSettings());1===s.length?Object.assign(t,e):Object.assign(t,{mqtt:e})}this.answer(AnswerMessage({sid:e.sid,to:e.from,...t}))}else this.answer(ParamErrorMessage({sid:e.sid,to:e.from}))}getMqttSettings(){let e=VIGServices.getServices("vmc").attrs.transfers,s=jsonpath.query(e,"$[?(@.name=='mqtt')]");return s.length>0?s[0]:{}}answer(e,s={}){}async report(e,s={}){}}class CloudDiscoverer extends DiscovererBase{constructor(e){super(e),this.settings=Object.assign({reportInterval:12e4,broker:"mqtt://mqtt.huanyutong.com",username:"vigateway",password:"@@!*@^^^",topics:["/voerka/discover/{sn}/config".params(VIGateway.sn)]},this.discoverService.attrs.cloudServer||{}),this.isConnected=!1}async serverIsOnline(e=1,s=3){let t=require("ping"),r=(await t.promise.probe("mqtt.huanyutong.com")).alive,i=0;return r||await new Promise((a,o)=>{setInterval(async()=>{i+=1;let s=await t.promise.probe("mqtt.huanyutong.com");s.alive&&(r=s.alive,a()),i>=e&&a()},1e3*s)}),r}async detectServer(){let e=await this.serverIsOnline(10);if(!e){if(!(await VIGPlatform.network.default()).dhcp){try{await VIGPlatform.network.configure({[VIGPlatform.network.defaultInterfaceName]:{dhcp:!0}}),this.isChangeNetwork=!0}catch(e){logger.debug(_("Error while configure network:{err}").params(e.message))}e=await this.serverIsOnline(10)}}return e}onConnected(){this.subscribeTopics().then(()=>{}),logger.debug(_("Connected to discover server <{server}> success.").params(this.settings.broker)),this.isConnected=!0}onError(e){logger.debug(_("Error while connecting to discover server <{server}>:{error}").params(this.settings.broker,e.message))}onReconnect(){logger.debug(_("Reconnecting to discover server <{server}>").params(this.settings.broker))}onDisconnected(){this.isConnected=!1,logger.debug(_("Disconnected from discover server <{server}>").params(this.settings.broker))}_assertMessageTimeout(e){if(e){try{"string"==typeof e&&(e=dayjs(e).valueOf()),"number"!=typeof e&&(e=parseInt(Number))}catch(e){throw new Error(_("Error <timestamp> parameters"))}assert((new Date).getTime()-e>6e5,"message is timeout")}}onMessage(e,s,t){let r={cmd:0};try{r=deserialize(s),logger.debug(_("Receive the discovery message:{message}").params(JSON.stringify(r)))}catch(e){return void this.answer(ErrorMessage({message:"Decoding message error:"+e.message}))}try{this._assertMessageTimeout(r.timestamp)}catch(e){return logger.debug(_("Discovery message is timeout,timestamp=:{timestamp}").params(String(r.timestamp))),void this.answer(ErrorMessage({sid:r.sid,to:r.from,message:e.message}))}let i=r.sid;try{switch(r.cmd){case 1:this.onBasicConfig(r);break;case 2:this.onNetworkConfig(r);break;case 3:this.onWifiConfig(r);break;case 4:this.onLocationConfig(r);break;case 5:this.onReset(r);break;case 6:this.onUpgrade(r);break;case 7:this.onSetAttrs(r);break;case 8:this.onGetAttrs(r);break;default:let e=_("Invalid discover command:<{cmd}>").params(String(r.cmd));logger.warn(e),this.answer(ErrorMessage({sid:i,to:r.from,message:e}))}}catch(e){this.answer(ErrorMessage({sid:i,to:r.from,message:e.message}))}}async connect(){let e={clientId:"voerka_{type}_{sn}".params(VIGateway.type.toLowerCase(),VIGateway.sn),wsOptions:{},keepalive:20,reschedulePings:!0,protocolId:"MQTT",protocolVersion:4,clean:!0,reconnectPeriod:1e4,connectTimeout:3e4,incomingStore:null,outgoingStore:null,queueQoSZero:!0};Object.assign(e,this.settings),logger.debug(_("Connecting to discover server <{server}>....").params(this.settings.broker)),this.endpoint=MQTT.connect(this.settings.broker,e),this.endpoint.on("connect",this.onConnected.bind(this)),this.endpoint.on("error",this.onError.bind(this)),this.endpoint.on("message",this.onMessage.bind(this)),this.endpoint.on("reconnect",this.onReconnect.bind(this)),this.endpoint.on("close",this.onDisconnected.bind(this));let s=(new Date).getTime();await new Promise((e,t)=>{let r=()=>{this.isConnected?e():(new Date).getTime()-s>8e3?e():setTimeout(r,100)};setTimeout(r,100)})}async disconnect(){await new Promise((e,s)=>{this.endpoint.end(!0,()=>{e()})}),await asyncWait(()=>!this.endpoint.connected)}async subscribeTopics(){logger.debug(_("Start subscribing to topic messages")),await this.unsubscribeTopics(),await new Promise((e,s)=>{this.endpoint.subscribe(this.settings.topics,{qos:2,reain:1},(t,r)=>{t?(logger.debug(_("Error while subscribe topic:{topics}\n{error}").params(this.settings.topics.join(","),t.message)),s(t)):(this._subscribed=!0,logger.debug(_("Subscribe topics success : {topics}").params(this.settings.topics.join(","))),e())})})}async unsubscribeTopics(){if(this._subscribed)return new Promise((e,s)=>{this.settings.topics.length>0&&this.endpoint.unsubscribe(this.settings.topics,s=>{s?(logger.debug(_("Error while unsubscribe topics:{err}").params(s.message)),e()):(this._subscribed=!1,e())})})}async start(){await super.start(),await this.detectServer()&&(await this.connect(),this.startTimingReport())}async stop(){await super.stop(),await this.unsubscribeTopics(),await this.disconnect()}async report(e,s={}){let t="/voerka/discover/{sn}".params(VIGateway.sn);s=Object.assign({qos:2,retain:1},s);try{this.endpoint.publish(t,serialize(e),s)}catch(e){logger.error(_("Error while send message in discover：{err}").params(e.message))}}async answer(e,s={}){if(!e.to)return;let t="/voerka/discover/configtor/"+String(e.to);s=Object.assign({qos:2,retain:0},s);try{this.endpoint.publish(t,serialize(e),s)}catch(e){logger.error(_("Error while send message in discover：{err}").params(e.message))}}}class DiscoverService extends ServiceBase{init(){this.inDiscover=!1}async start(){}async stop(){}async enterDiscover(){if(!this.inDiscover){logger.info(_("Entering the discovery mode."));try{this.cloudDiscover=new CloudDiscoverer(this),await this.cloudDiscover.start(),this.inDiscover=!0}catch(e){logger.error(_("Error while entering the discovery mode"))}}}async leaveDiscover(){if(this.inDiscover)try{await this.cloudDiscover.stop(),logger.info(_("Leave the discovery mode.")),this.inDiscover=!1}catch(e){logger.error(_("Error while Leave the discovery mode"))}}async onNotify(e){e.event===Notifys.HostModeChange&&(1!==e.mode||this.inDiscover?this.inDiscover&&(await this.leaveDiscover(),this.node.notify(Notifys.HostDiscoverMode,{discover:!1})):(this.node.notify(Notifys.HostDiscoverMode,{discover:!0}),await this.enterDiscover()))}}module.exports=DiscoverService;